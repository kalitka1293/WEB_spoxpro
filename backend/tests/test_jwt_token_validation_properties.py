"""
Property-based tests for JWT token validation functionality.

**Feature: spoxpro-backend, Property 6: JWT Token Validation**
**Validates: Requirements 2.3**

For any JWT token generated by the system, token validation should correctly extract 
the user ID, and for any invalid or expired token, validation should fail appropriately.
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import pytest
from hypothesis import given, strategies as st, settings, HealthCheck
from datetime import datetime, timedelta
from jose import jwt, JWTError
import secrets
import string

from service.auth_service import AuthService
from db.services.user_service import UserService
from config.settings import get_settings
from db.main import get_db_session


# Custom strategies for better data generation
@st.composite
def valid_password(draw):
    """Generate valid passwords with at least one letter and one digit, respecting bcrypt 72-byte limit."""
    # Generate a password that's guaranteed to be under 72 bytes
    # Use simple ASCII characters to avoid encoding issues
    letters = draw(st.text(alphabet=string.ascii_letters, min_size=3, max_size=15))
    digits = draw(st.text(alphabet=string.digits, min_size=2, max_size=8))
    
    # Combine and ensure it's not too long
    password = letters + digits
    
    # Ensure minimum length of 8
    if len(password) < 8:
        extra_chars = draw(st.text(alphabet=string.ascii_letters + string.digits, 
                                 min_size=8-len(password), max_size=8-len(password)))
        password += extra_chars
    
    # Ensure it's under 60 characters to be safe with bcrypt (well under 72 bytes)
    return password[:60]

@st.composite
def valid_phone(draw):
    """Generate valid phone numbers."""
    return draw(st.text(alphabet=string.digits, min_size=10, max_size=15))


class TestJWTTokenValidationProperties:
    """Property-based tests for JWT token validation."""
    
    @pytest.fixture(autouse=True)
    def setup(self):
        """Set up test dependencies."""
        self.settings = get_settings()
        self.session = get_db_session()
        self.user_service = UserService(self.session)
        self.auth_service = AuthService(self.user_service)
    
    def teardown_method(self):
        """Clean up after each test."""
        if hasattr(self, 'session'):
            self.session.close()
    
    # ==================== VALID TOKEN PROPERTIES ====================
    
    @given(
        email=st.emails(),
        password=valid_password(),
        phone=valid_phone()
    )
    @settings(max_examples=100, deadline=None, suppress_health_check=[HealthCheck.filter_too_much])
    def test_valid_token_extraction_property(self, email, password, phone):
        """
        Property: For any JWT token generated by the system, token validation 
        should correctly extract the user ID and email.
        
        **Validates: Requirements 2.3**
        """
        user = None
        try:
            # Create a user
            user_data = {
                "email": email,
                "password": password,
                "phone": phone
            }
            user = self.user_service.create_user(user_data)
            
            # Skip test if user creation fails (e.g., duplicate email)
            if user is None:
                return
            
            # Generate JWT token
            token_info = self.auth_service.generate_jwt_token(user)
            token = token_info["access_token"]
            
            # Validate token
            validation_result = self.auth_service.validate_jwt_token(token)
            
            # Property assertions
            assert validation_result is not None, "Valid token should be successfully validated"
            assert validation_result["user_id"] == user.id, "Token should contain correct user ID"
            assert validation_result["email"] == user.email, "Token should contain correct email"
            assert "expires_at" in validation_result, "Token should contain expiration time"
            
            # Verify expiration time is in the future
            assert validation_result["expires_at"] > datetime.utcnow(), "Token should not be expired"
            
            # Verify user can be retrieved from token
            retrieved_user = self.auth_service.get_user_from_token(token)
            assert retrieved_user is not None, "User should be retrievable from valid token"
            assert retrieved_user.id == user.id, "Retrieved user should match original user"
            
        except Exception as e:
            # Clean up on error
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass
            raise e
        finally:
            # Clean up created user
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass
    
    @given(
        email=st.emails(),
        password=valid_password(),
        phone=valid_phone()
    )
    @settings(max_examples=100, deadline=None, suppress_health_check=[HealthCheck.filter_too_much])
    def test_token_consistency_property(self, email, password, phone):
        """
        Property: Multiple validations of the same valid token should return 
        consistent results.
        
        **Validates: Requirements 2.3**
        """
        user = None
        try:
            # Create a user
            user_data = {
                "email": email,
                "password": password,
                "phone": phone
            }
            user = self.user_service.create_user(user_data)
            
            # Skip test if user creation fails (e.g., duplicate email)
            if user is None:
                return
            
            # Generate JWT token
            token_info = self.auth_service.generate_jwt_token(user)
            token = token_info["access_token"]
            
            # Validate token multiple times
            result1 = self.auth_service.validate_jwt_token(token)
            result2 = self.auth_service.validate_jwt_token(token)
            result3 = self.auth_service.validate_jwt_token(token)
            
            # Property assertions - all results should be identical
            assert result1 == result2 == result3, "Multiple validations should return identical results"
            assert all(r is not None for r in [result1, result2, result3]), "All validations should succeed"
            
        except Exception as e:
            # Clean up on error
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass
            raise e
        finally:
            # Clean up created user
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass
    
    # ==================== INVALID TOKEN PROPERTIES ====================
    
    @given(
        invalid_token=st.one_of(
            st.text(min_size=1, max_size=100).filter(lambda x: not x.startswith("eyJ")),  # Not JWT format
            st.just(""),  # Empty string
            st.just("invalid.token.format"),  # Invalid format
            st.text(alphabet=string.ascii_letters + string.digits + ".-_", min_size=10, max_size=200)  # Random string
        )
    )
    @settings(max_examples=100, deadline=None, suppress_health_check=[HealthCheck.filter_too_much])
    def test_invalid_token_rejection_property(self, invalid_token):
        """
        Property: For any invalid token format, validation should fail appropriately.
        
        **Validates: Requirements 2.3**
        """
        # Validate invalid token
        validation_result = self.auth_service.validate_jwt_token(invalid_token)
        
        # Property assertion
        assert validation_result is None, "Invalid token should be rejected"
        
        # Verify user cannot be retrieved from invalid token
        retrieved_user = self.auth_service.get_user_from_token(invalid_token)
        assert retrieved_user is None, "User should not be retrievable from invalid token"
    
    @given(
        email=st.emails(),
        password=valid_password(),
        phone=valid_phone()
    )
    @settings(max_examples=100, deadline=None, suppress_health_check=[HealthCheck.filter_too_much])
    def test_expired_token_rejection_property(self, email, password, phone):
        """
        Property: For any expired token, validation should fail appropriately.
        
        **Validates: Requirements 2.3**
        """
        user = None
        try:
            # Create a user
            user_data = {
                "email": email,
                "password": password,
                "phone": phone
            }
            user = self.user_service.create_user(user_data)
            
            # Skip test if user creation fails (e.g., duplicate email)
            if user is None:
                return
            
            # Create an expired token manually
            expired_time = datetime.utcnow() - timedelta(minutes=1)  # 1 minute ago
            payload = {
                "sub": str(user.id),
                "email": user.email,
                "exp": expired_time,
                "iat": datetime.utcnow() - timedelta(minutes=2),
                "type": "access_token"
            }
            
            expired_token = jwt.encode(
                payload,
                self.settings.jwt_secret_key,
                algorithm=self.settings.jwt_algorithm
            )
            
            # Validate expired token
            validation_result = self.auth_service.validate_jwt_token(expired_token)
            
            # Property assertion
            assert validation_result is None, "Expired token should be rejected"
            
            # Verify user cannot be retrieved from expired token
            retrieved_user = self.auth_service.get_user_from_token(expired_token)
            assert retrieved_user is None, "User should not be retrievable from expired token"
            
        except Exception as e:
            # Clean up on error
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass
            raise e
        finally:
            # Clean up created user
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass
    
    @given(
        email=st.emails(),
        password=valid_password(),
        phone=valid_phone(),
        wrong_secret=st.text(min_size=32, max_size=64)
    )
    @settings(max_examples=100, deadline=None, suppress_health_check=[HealthCheck.filter_too_much])
    def test_wrong_secret_rejection_property(self, email, password, phone, wrong_secret):
        """
        Property: For any token signed with wrong secret, validation should fail.
        
        **Validates: Requirements 2.3**
        """
        user = None
        try:
            # Skip if wrong_secret is same as actual secret
            if wrong_secret == self.settings.jwt_secret_key:
                return
                
            # Create a user
            user_data = {
                "email": email,
                "password": password,
                "phone": phone
            }
            user = self.user_service.create_user(user_data)
            
            # Skip test if user creation fails (e.g., duplicate email)
            if user is None:
                return
            
            # Create a token with wrong secret
            payload = {
                "sub": str(user.id),
                "email": user.email,
                "exp": datetime.utcnow() + timedelta(minutes=30),
                "iat": datetime.utcnow(),
                "type": "access_token"
            }
            
            wrong_token = jwt.encode(
                payload,
                wrong_secret,
                algorithm=self.settings.jwt_algorithm
            )
            
            # Validate token with wrong secret
            validation_result = self.auth_service.validate_jwt_token(wrong_token)
            
            # Property assertion
            assert validation_result is None, "Token with wrong secret should be rejected"
            
            # Verify user cannot be retrieved from token with wrong secret
            retrieved_user = self.auth_service.get_user_from_token(wrong_token)
            assert retrieved_user is None, "User should not be retrievable from token with wrong secret"
            
        except Exception as e:
            # Clean up on error
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass
            raise e
        finally:
            # Clean up created user
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass
    
    # ==================== TOKEN PAYLOAD MANIPULATION PROPERTIES ====================
    
    @given(
        email=st.emails(),
        password=valid_password(),
        phone=valid_phone(),
        fake_user_id=st.integers(min_value=999999, max_value=9999999)
    )
    @settings(max_examples=100, deadline=None, suppress_health_check=[HealthCheck.filter_too_much])
    def test_nonexistent_user_rejection_property(self, email, password, phone, fake_user_id):
        """
        Property: For any token containing a non-existent user ID, validation should fail.
        
        **Validates: Requirements 2.3**
        """
        user = None
        try:
            # Create a user to get valid email format
            user_data = {
                "email": email,
                "password": password,
                "phone": phone
            }
            user = self.user_service.create_user(user_data)
            
            # Skip test if user creation fails (e.g., duplicate email)
            if user is None:
                return
            
            # Ensure fake_user_id is different from real user ID
            if fake_user_id == user.id:
                return
            
            # Create a token with non-existent user ID
            payload = {
                "sub": str(fake_user_id),  # Non-existent user ID
                "email": user.email,
                "exp": datetime.utcnow() + timedelta(minutes=30),
                "iat": datetime.utcnow(),
                "type": "access_token"
            }
            
            fake_token = jwt.encode(
                payload,
                self.settings.jwt_secret_key,
                algorithm=self.settings.jwt_algorithm
            )
            
            # Validate token with non-existent user
            validation_result = self.auth_service.validate_jwt_token(fake_token)
            
            # Property assertion
            assert validation_result is None, "Token with non-existent user ID should be rejected"
            
            # Verify user cannot be retrieved
            retrieved_user = self.auth_service.get_user_from_token(fake_token)
            assert retrieved_user is None, "Non-existent user should not be retrievable"
            
        except Exception as e:
            # Clean up on error
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass
            raise e
        finally:
            # Clean up created user
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass
    
    @given(
        email1=st.emails(),
        email2=st.emails(),
        password=valid_password(),
        phone=valid_phone()
    )
    @settings(max_examples=100, deadline=None, suppress_health_check=[HealthCheck.filter_too_much])
    def test_email_mismatch_rejection_property(self, email1, email2, password, phone):
        """
        Property: For any token where the email doesn't match the user's current email,
        validation should fail.
        
        **Validates: Requirements 2.3**
        """
        user = None
        try:
            # Skip if emails are the same
            if email1 == email2:
                return
            
            # Create a user with email1
            user_data = {
                "email": email1,
                "password": password,
                "phone": phone
            }
            user = self.user_service.create_user(user_data)
            
            # Skip test if user creation fails (e.g., duplicate email)
            if user is None:
                return
            
            # Create a token with email2 (different email)
            payload = {
                "sub": str(user.id),
                "email": email2,  # Different email
                "exp": datetime.utcnow() + timedelta(minutes=30),
                "iat": datetime.utcnow(),
                "type": "access_token"
            }
            
            mismatched_token = jwt.encode(
                payload,
                self.settings.jwt_secret_key,
                algorithm=self.settings.jwt_algorithm
            )
            
            # Validate token with mismatched email
            validation_result = self.auth_service.validate_jwt_token(mismatched_token)
            
            # Property assertion
            assert validation_result is None, "Token with mismatched email should be rejected"
            
            # Verify user cannot be retrieved
            retrieved_user = self.auth_service.get_user_from_token(mismatched_token)
            assert retrieved_user is None, "User should not be retrievable with mismatched email token"
            
        except Exception as e:
            # Clean up on error
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass
            raise e
        finally:
            # Clean up created user
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass

    # ==================== ADDITIONAL EDGE CASE PROPERTIES ====================
    
    @given(
        email=st.emails(),
        password=valid_password(),
        phone=valid_phone()
    )
    @settings(max_examples=100, deadline=None, suppress_health_check=[HealthCheck.filter_too_much])
    def test_token_structure_validation_property(self, email, password, phone):
        """
        Property: For any valid token, it should contain all required JWT fields
        and proper structure.
        
        **Validates: Requirements 2.3**
        """
        user = None
        try:
            # Create a user
            user_data = {
                "email": email,
                "password": password,
                "phone": phone
            }
            user = self.user_service.create_user(user_data)
            
            # Skip test if user creation fails (e.g., duplicate email)
            if user is None:
                return
            
            # Generate JWT token
            token_info = self.auth_service.generate_jwt_token(user)
            token = token_info["access_token"]
            
            # Decode token without validation to check structure
            unverified_payload = jwt.get_unverified_claims(token)
            
            # Property assertions - token should have proper structure
            assert "sub" in unverified_payload, "Token should contain 'sub' field"
            assert "email" in unverified_payload, "Token should contain 'email' field"
            assert "exp" in unverified_payload, "Token should contain 'exp' field"
            assert "iat" in unverified_payload, "Token should contain 'iat' field"
            assert "type" in unverified_payload, "Token should contain 'type' field"
            
            # Verify field values
            assert unverified_payload["sub"] == str(user.id), "Subject should match user ID"
            assert unverified_payload["email"] == user.email, "Email should match user email"
            assert unverified_payload["type"] == "access_token", "Type should be 'access_token'"
            
            # Verify expiration is after issued time
            exp_time = unverified_payload["exp"]
            iat_time = unverified_payload["iat"]
            assert exp_time > iat_time, "Expiration time should be after issued time"
            
        except Exception as e:
            # Clean up on error
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass
            raise e
        finally:
            # Clean up created user
            if user:
                try:
                    self.user_service.delete_user(user.id)
                except:
                    pass

    @given(
        malformed_token=st.one_of(
            st.just("eyJ"),  # Incomplete JWT
            st.just("eyJ."),  # Missing parts
            st.just("eyJ.eyJ"),  # Missing signature
            st.just("not.a.jwt"),  # Invalid base64
            st.text(alphabet="!@#$%^&*()", min_size=10, max_size=50),  # Invalid characters
        )
    )
    @settings(max_examples=100, deadline=None)
    def test_malformed_token_rejection_property(self, malformed_token):
        """
        Property: For any malformed JWT token, validation should fail gracefully.
        
        **Validates: Requirements 2.3**
        """
        # Validate malformed token
        validation_result = self.auth_service.validate_jwt_token(malformed_token)
        
        # Property assertion
        assert validation_result is None, "Malformed token should be rejected"
        
        # Verify user cannot be retrieved from malformed token
        retrieved_user = self.auth_service.get_user_from_token(malformed_token)
        assert retrieved_user is None, "User should not be retrievable from malformed token"